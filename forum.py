from __future__ import annotations

import requests
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import wrapt
import logging

LOG = logging.getLogger(__file__)

AUTO_TO_TEMPLATE = "{body}\n\n<sub>This post generated by [Yomi Auto TO](https://github.com/cpennington/yomi-auto-to).</sub>"


@wrapt.decorator
def paged(wrapped, instance, args, kwargs):
    current_page = wrapped(*args, **kwargs)

    while True:
        for topic in current_page.json()["topic_list"]["topics"]:
            if topic["pinned"]:
                continue
            yield topic
        more_topics = current_page.json()["topic_list"].get("more_topics_url")
        if more_topics:
            current_page = instance.session.get(instance.url(more_topics))
        else:
            break


class Forum:
    SECONDS_BETWEEN_POSTS = 16

    def __init__(self, db, baseurl, username, password):
        self.db = db
        self.baseurl = baseurl
        self.session = requests.session()
        self.session.headers["Accept"] = "application/json"
        LOG.debug("DB headers: %r", self.headers)
        self.session.headers.update(self.headers)
        LOG.debug("DB cookies: %r", self.cookies)
        self.session.cookies.update(self.cookies)
        LOG.debug("Session headers: %r", self.session.headers)
        LOG.debug("Session cookies: %r", self.session.cookies)
        self.username = username
        self.password = password

        self.last_post = 0

    @property
    def logged_in(self) -> bool:
        return self.db["cookies"].find_one() is not None

    @property
    def headers(self) -> requests.structures.CaseInsensitiveDict[str]:
        return requests.structures.CaseInsensitiveDict(
            {
                str(header["name"]): str(header["value"])
                for header in self.db["headers"].find()
            }
        )

    @headers.setter
    def headers(self, headers: requests.structures.CaseInsensitiveDict[str]) -> None:
        self.db["headers"].delete()
        for name, value in headers.items():
            self.db["headers"].insert({"name": name, "value": value})

    @headers.deleter
    def headers(self) -> None:
        self.db["headers"].delete()

    @property
    def cookies(self) -> requests.cookies.RequestsCookieJar:
        return requests.cookies.cookiejar_from_dict(
            {header["name"]: header["value"] for header in self.db["cookies"].find()}
        )

    @cookies.setter
    def cookies(self, cookies: requests.cookies.RequestsCookieJar) -> None:
        self.db["cookies"].delete()
        for name, value in cookies.items():
            self.db["cookies"].insert({"name": name, "value": value})

    @cookies.deleter
    def cookies(self) -> None:
        self.db["cookies"].delete()

    def login(self):
        if self.logged_in:
            return

        # retries = Retry(total=5, backoff_factor=10, status_forcelist=[429], method_whitelist=['POST'])
        # self.session.mount('http://', HTTPAdapter(max_retries=retries))

        csrf_resp = self.session.get(
            self.url("session/csrf"), data={"_": time.time() * 1000}
        )
        csrf_resp.raise_for_status()

        self.session.headers["X-CSRF-Token"] = csrf_resp.json()["csrf"]

        login_resp = self.session.post(
            self.url("session"), data=dict(login=self.username, password=self.password)
        )
        if login_resp.status_code == 429:
            print(login_resp.json())
            print(
                "Waiting {} seconds".format(login_resp.json()["extras"]["wait_seconds"])
            )
            time.sleep(login_resp.json()["extras"]["wait_seconds"])
        login_resp.raise_for_status()

        check_resp = self.session.get(self.url("session/current.json"))
        check_resp.raise_for_status()

        self.headers = self.session.headers
        self.cookies = self.session.cookies

    def url(self, endpoint):
        return f"{self.baseurl}/{endpoint}"

    @paged
    def private_messages(self, suffix=None):
        self.login()
        suffix = f"-{suffix}" if suffix is not None else ""
        return self.session.get(
            self.url(f"topics/private-messages{suffix}/{self.username}.json")
        )

    @paged
    def public_threads(self, category=None, order="activity"):
        self.login()
        category = f"c/{category}/l/" if category is not None else ""
        return self.session.get(self.url(f"{category}latest.json?order={order}"))

    def message(self, id):
        self.login()
        url = self.url(f"t/{id}.json")
        LOG.debug("Fetching message from %s", url)
        return self.session.get(url)

    def reply_to(self, topic_id, body):
        self.login()
        data = {
            "raw": AUTO_TO_TEMPLATE.format(body=body),
            "topic_id": topic_id,
            "archetype": "regular",
            "typing_duration_msecs": 0,
            "composer_open_duration_msecs": 0,
        }
        seconds_since_last_post = time.time() - self.last_post
        if seconds_since_last_post < self.SECONDS_BETWEEN_POSTS:
            time.sleep(self.SECONDS_BETWEEN_POSTS - seconds_since_last_post)

        resp = self.session.post(self.url("posts"), data=data)
        self.last_post = time.time()
        return resp

    def message_posts(self, id):
        self.login()
        message = self.message(id)
        LOG.debug("Loaded message:\n%s", message)
        yield from message.json()["post_stream"]["posts"]

    def send_private_message(self, recipients, title, body):
        self.login()

        data = {
            "raw": AUTO_TO_TEMPLATE.format(body=body),
            "title": title,
            "unlist_topic": "false",
            "category": "",
            "is_warning": "false",
            "archetype": "private_message",
            "target_usernames": ",".join(recipients),
            "typing_duration_msecs": 0,
            "composer_open_duration_msecs": 0,
            "featured_link": "",
            "nested_post": "true",
        }
        seconds_since_last_post = time.time() - self.last_post
        if seconds_since_last_post < self.SECONDS_BETWEEN_POSTS:
            time.sleep(self.SECONDS_BETWEEN_POSTS - seconds_since_last_post)

        resp = self.session.post(self.url("posts"), data=data)
        self.last_post = time.time()
        return resp

    def search_user(self, name):
        self.login()

        return self.session.get(
            self.url("/u/search/users"),
            data={
                "term": name,
                "include_groups": "false",
                "include_mentionable_groups": "false",
                "include_messageable_groups": "true",
                "topic_allowed_users": "false",
            },
        )
